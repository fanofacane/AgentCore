## 目的
帮助在后端（Java 业务层）与数据库（SQL）之间做“数据处理位置”决策，兼顾性能、可维护性与一致性。

## 核心原则
- **让数据库做集合型计算**：过滤、排序、分页、聚合、分组、Top-N、去重、存在性判断。
- **让后端做业务编排**：权限、事务边界、幂等/重试、跨系统调用、复杂规则组合、审计。
- **目标不是“都下推”**，而是：**把能显著减少返回行数/中间对象的步骤尽量下推**，把易变/复杂/跨系统的步骤留在后端。

## 什么时候优先在数据库做（推荐下推）
### 1) 过滤/排序/分页（收益最高）
- 典型：`WHERE`、`ORDER BY`、`LIMIT/OFFSET`。
- 原因：减少返回行数 → 直接降低网络传输、ORM 反序列化、应用端内存与 GC。

### 2) 聚合/分组/Top-N
- 典型：`COUNT/SUM/MAX/MIN/AVG`、`GROUP BY`、窗口函数。
- 适用场景：
  - “每个 agent 取最新版本”
  - “按 session 聚合统计”
  - “成功率/总token/调用次数”

### 3) 去重/存在性判断
- 典型：`DISTINCT`、`EXISTS`。
- 适用场景：权限存在性校验、列表页去重。

### 4) 简单派生字段
- 典型：`CASE WHEN`、简单比例/标志位。
- 注意：派生字段应只依赖当前查询范围内数据，避免引入复杂子查询。

## 什么时候优先在后端做（不建议下推）
### 1) 跨系统/外部资源
- 文件存储、对象存储、消息队列、第三方 API。
- 原因：SQL 不擅长流程控制与补偿机制。

### 2) 强一致性编排与补偿
- 需要事务边界、幂等、重试、补偿的流程（删除/下架/级联清理、发消息、定时任务取消等）。

### 3) 复杂且易变的业务规则
- 规则频繁变化、组合复杂、可读性要求高（例如多条件策略树）。
- 建议：后端实现规则；SQL 只做必要过滤。

### 4) 权限/审计
- SQL 可用于辅助过滤（比如 `WHERE user_id=?`），但核心权限校验与审计落点通常应在后端。

## 风险与约束（决定“下推多少”）
- **DB 压力**：下推会把计算压力放到数据库，需关注执行计划与索引。
- **索引要求**：无索引的聚合/排序下推可能更慢；需补联合索引。
- **可维护性**：复杂 SQL 难维护，建议集中在 Mapper 并配套说明/测试。
- **方言差异**：PostgreSQL/MySQL/Oracle 在窗口函数、ILIKE 等有差异。

## 决策清单（落地用）
1. 这一步能显著减少返回行数或字段吗？能 → 优先 SQL。
2. 这一步是集合运算（过滤/聚合/Top-N/去重）吗？是 → 优先 SQL。
3. 这一步涉及外部系统、复杂流程、补偿/幂等吗？是 → 优先后端。
4. 下推后有合适索引、执行计划可控吗？没有 → 先补索引或改 SQL。

## 结合你们当前代码的典型例子
### 示例A：工作区 getAgents
- 推荐数据库做：
  - “每个 agent 取最新 PUBLISHED，否则取最新 REMOVED”
  - 原因：避免把 agent_versions 全量行拉回内存再分组。
- 推荐后端做：
  - DTO 组装、兜底逻辑（无版本时回退 agents）。

### 示例B：删除/下架 Agent
- 推荐后端做：
  - 事务编排：停用/写 deletedAt、下架版本、清理用户会话/消息/追踪、取消定时任务。
- 推荐数据库做：
  - 批量 delete/update（按 userId、agentId、sessionIds 分批）。

## 推荐的性能验证方法（不依赖改业务）
- 记录关键指标：
  - SQL 返回行数、接口耗时、堆内存峰值、Young GC 次数。
- 观察优化方向：
  - “把行数降下来”通常比“微优化 Java 代码”收益更大。
