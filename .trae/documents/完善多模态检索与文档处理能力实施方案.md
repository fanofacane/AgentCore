## 结论
- 当前上传阶段通过 MultipartFile 与 X-File-Storage 落库，通常以临时文件+流式写入，不必完全驻留内存；但若未正确配置阈值，超大文件会造成请求体在内存/磁盘上占用过高。
- 处理阶段（OCR/解析）按页或按段执行，仍存在内存峰值风险：PDF 每页渲染 BufferedImage、POI 解析大文档、并发过高导致多页同时驻留。
- 分片上传能显著缓解“上传阶段”的内存与网络压力，但不能直接解决“处理阶段”的内存峰值；需配合并发控制与按页释放内存。

## 现状内存占用点
- 上传：Spring Multipart 阈值与缓存（需配置 file-size-threshold/max-file-size/max-request-size）。
- 存储：X-File-Storage 流式写入 S3，内存占用相对可控。
- OCR：PDFBox 按页渲染为 BufferedImage 后转 Base64（DPI/页尺寸影响大）；POI 解析 Word/PPT 可能加载较多对象。
- 并发：Rabbit 消费者并行处理可能导致同一时刻多页图像/文档段落驻留内存。

## 优化与实现
- 分片上传（前端直传 + 服务端签名）
  - 后端提供 init/uploadPart/listParts/complete 接口；CreateMultipartUpload 生成 uploadId 并返回分片策略与预签名 URL；complete 时合并分片并更新 FileDetailEntity，触发现有 OCR→向量化流水线。
  - uploadId 必须由后端向对象存储生成并返回，前端只负责持有与上传；支持断点续传通过 listParts 恢复。
- 上传阶段内存安全
  - 配置 spring.servlet.multipart.file-size-threshold（落磁盘）、max-file-size、max-request-size；限制单文件/请求体大小并快速拒绝异常超限。
  - 使用临时文件存储与流式转存到对象存储，避免整文件驻内存。
- 处理阶段内存控制
  - PDF：按页处理并立即释放 BufferedImage；降低渲染 DPI、限制并发页数；大页分辨率下启用压缩或降采样。
  - POI：优先使用流式解析模式（适用于 XLSX），为 PPTX/Word 设置分段切片与分页控制；避免一次性加载全文。
  - MQ 并发与背压：降低 RagDocConsumer/RagDocStorageConsumer 的并发与预取（prefetch），确保页面级串行或小并发；失败重试间隔退避。
- 保护与限流
  - 输入限制：文件类型白名单与最大页数/大小限制；超限直接拒绝并返回指导信息。
  - 资源配额：为 OCR 与向量化执行器设置最大并行度与内存水位报警；JVM 堆与容器资源监控。

## 交付要点
- 新增分片上传接口与服务实现（init/part/listParts/complete/abort）；整合到现有 UploadController 或新增 UploadController。
- 配置上传阈值与大小限制；调小消费者并发与预取；为 PDF 渲染设置可配置 DPI 与并发控制。
- 验证大文件场景：>500MB PDF、长 Docx/PPT；观察内存峰值与处理耗时，确保无 OOM。

确认该方案后，我将按此路径补齐接口与服务实现，并调整相关配置与并发参数。