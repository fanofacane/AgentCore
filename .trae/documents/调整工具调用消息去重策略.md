# 工具调用消息去重方案调整

您提出的建议非常合理。相比于在 `ParallelStreamingAgent` 内部维护去重逻辑（这可能会因为递归和实例生命周期问题导致复杂化），在 `AbstractMessageHandler` 这一层统一处理消息发送时的去重更加直接和稳健。

## 修改计划

### 1. 回滚 `ParallelStreamingAgent.java`
我们将移除之前在 `ParallelStreamingAgent` 中添加的 `processedToolIds` 逻辑，将其恢复到纯粹的并发执行状态。这样 Agent 只需要关注执行，不需要关注消息展示的细节。

### 2. 修改 `AbstractMessageHandler.java`
我们将在 `processChat` 方法中引入一个去重集合 `executedToolIds`。

**具体步骤：**
1.  **定义去重集合**：在 `processChat` 方法开始处，定义一个线程安全的 `Set<String> executedToolIds = ConcurrentHashMap.newKeySet();`。
2.  **修改 `onToolExecuted` 回调**：
    *   在回调内部，使用 `executedToolIds.contains(toolExecution.request().id())` 检查该工具请求是否已处理过。
    *   如果已存在，则**直接返回**，不发送任何消息，也不记录重复的日志。
    *   如果不存在，则将 ID 加入集合，并继续执行后续的消息发送和日志记录逻辑。

**代码预览：**
```java
Set<String> executedToolIds = ConcurrentHashMap.newKeySet();

tokenStream.onToolExecuted(toolExecution -> {
    // 去重检查
    if (!executedToolIds.add(toolExecution.request().id())) {
        return; // 已处理过，跳过
    }

    String message = "执行工具:" + toolExecution.request().name();
    // 发送消息...
});
```

这种方案将去重逻辑提升到了业务处理层（Handler），使得底层的 Agent 实现更加干净，同时也更能确保在任何 Agent 实现下（无论是串行还是并行）都能有效地控制前端消息的展示。
